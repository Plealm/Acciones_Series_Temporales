---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
library(quantmod)

symbol <- "BC"
start_date <- "2000-01-01"
end_date <- "2020-01-01"

# Descarga los datos históricos de acciones de Bancolombia
getSymbols(symbol, src = "yahoo", from = start_date, to = end_date)

# Extrae la fecha y el precio de cierre ('Close') y resetea el índice
data <- data.frame(Date = index(BC), Close = Cl(BC))
data1 <- data.frame(Close = Cl(BC))
data2 <- data[, -1]
data3 <- data.frame(Date = index(BC), Close = data2)
head(data1)
head(data2)
tail(data3)
```

```{r}
plot(data1)
```

```{r}
plot(data2)
```

```{r}
plot(data3)
```

```{r}
library(MASS) #Libreria para hacer la grafica
library(forecast)
# List of data frames (data1, data2, data3) with corresponding names
data_list <- list(data1 = data1, data2 = data2)

# Iterate over the list of data frames
for (i in seq_along(data_list)) {
  # Perform Box-Cox transformation analysis
  b <- boxcox(lm(unlist(data_list[[i]]) ~ 1))
  lambda <- b$x[which.max(b$y)]
  
  # Plot the result with the name of the data frame in the title
  title(main = paste("Box-Cox Transformation with Lambda =", round(lambda, 3), "for", names(data_list)[i]))
  abline(v = lambda, col = "red")
  
  # Apply Box-Cox transformation with the lambda found
  transformed_data <- forecast::BoxCox(unlist(data_list[[i]]), lambda = lambda)
  
  # Convert date index to character
  dates <- as.character(index(data_list[[i]]))
  
  # Plot original and transformed data
  plot(dates, unlist(data_list[[i]]), type = "l", col = "blue", ylim = range(c(unlist(data_list[[i]]), transformed_data)), xlab = "Date", ylab = "Value", main = paste("Data and Transformed Data for", names(data_list)[i]))
  lines(dates, transformed_data, col = "red")
  legend("topright", legend = c("Original", "Transformed"), col = c("blue", "red"), lty = 1)
  
  trend_lowess <- stats::lowess(transformed_data, f = 0.075)

# Remover la tendencia del conjunto de datos transformados
detrended_data <- transformed_data - trend_lowess$y

# Crear el gráfico con y sin la tendencia
plot(transformed_data, type="l", col="red", ylab="Transformed Data with Trend", main=paste("Original Data, Lowess Trend, and Detrended Data", names(data_list)[i]), ylim=c(-8, max(transformed_data)))
lines(trend_lowess, col="blue", lty=2)
lines(detrended_data, col="green", lty=2)
legend("topright", legend=c("Transformed Data", "Lowess Trend", "Detrended Data"), col=c("red", "blue", "green"))

Periogram=spectrum(as.numeric(detrended_data),log='no')
# Get the index where the periodogram maximizes
ubicacion <- which.max(Periogram$spec)

# Get the frequency value at the index where the periodogram maximizes
max_freq <- Periogram$freq[ubicacion]

# Print the frequency value
sprintf("The value of the frequency where the periodogram maximizes for the series is: %s", max_freq)
sprintf("El periodo correspondiente es aproximadamente: %s",1/Periogram$freq[ubicacion])
}

```

```{r}
# Calculate the periodogram
Periogram <- spectrum(as.numeric(detrended_data), log = 'no')

# Get the index where the periodogram maximizes
ubicacion <- which.max(Periogram$spec)

# Get the frequency value at the index where the periodogram maximizes
max_freq <- Periogram$freq[ubicacion]

# Calculate the corresponding period
max_period <- 1 / max_freq

# Plot the periodogram

# Add text annotation for frequency and period
text(.27, 4.5, sprintf("Frecuencia: %s", round(max_freq, 5)), pos = 4)
text(.3, 5, sprintf("Periodo: %s", round(max_period, 2)), pos = 4)


```

 

```{r}
# Instalar paquetes si no están instalados
if (!requireNamespace("quantmod", quietly = TRUE)) {
  install.packages("quantmod")
}

if (!requireNamespace("forecast", quietly = TRUE)) {
  install.packages("forecast")
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

# Cargar paquetes
library(quantmod)
library(forecast)
library(ggplot2)

# 1. Extraer datos desde 2000-01-01 al 2020-01-01 de las acciones de Bancolombia (BC) con quantmod
getSymbols("BC", src = "yahoo", from = "2000-01-01", to = "2020-01-01", auto.assign = TRUE)
bc_data <- data.frame(Date = index(BC), Close = as.numeric(Cl(BC)))

# 2. Corregir la varianza con Boxcox
bc_returns <- diff(log(bc_data$Close))
lambda <- BoxCox.lambda(bc_returns)
bc_returns_boxcox <- BoxCox(bc_returns, lambda)

# 3. Quitar la tendencia por medio de loess
trend <- loess(bc_returns_boxcox ~ time(bc_returns_boxcox))
bc_detrended <- residuals(trend)

# 4. Graficar el periodograma
per <- spec.pgram(bc_detrended, log = "no")
plot(per, main = "Periodograma")

# 5. Graficar el montplot()
montplot(bc_detrended, main = "Montgomery Plot")

# 6. Graficar ggseasonplot
bc_ts <- ts(bc_detrended)
seasonal_decomposition <- decompose(bc_ts)
ggseasonplot(seasonal_decomposition, main = "Seasonal Decomposition")

# Guardar los gráficos (opcional)
# ggsave("montgomery_plot.png", plot = last_plot(), device = "png")
# ggsave("seasonal_decomposition_plot.png", plot = last_plot(), device = "png")


```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
